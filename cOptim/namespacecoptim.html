<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cOptim: coptim Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cOptim
   &#160;<span id="projectnumber">alpha 0.3</span>
   </div>
   <div id="projectbrief">Global optimization algorithms ported to C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">coptim Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_adaptive_stepsize.html">AdaptiveStepsize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates randomized candidate solutions with an adaptive step size.  <a href="classcoptim_1_1_adaptive_stepsize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1anneal__params.html">anneal_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that are passed to the anneal function.  <a href="structcoptim_1_1anneal__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1base__schedule.html">base_schedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for cooling schedules. This is the class from which all cooling schedules are derived.  <a href="classcoptim_1_1base__schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1base__schedule__params.html">base_schedule_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organizes the parameters when initializing a cooling schedule. This is an internal struct used to organize parameters before constructing a cooling schedule.  <a href="structcoptim_1_1base__schedule__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1basin__params.html">basin_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that are passed to the basinhopping function.  <a href="structcoptim_1_1basin__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_basin_hopping_runner.html">BasinHoppingRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the core of the basinhopping algorithm.  <a href="classcoptim_1_1_basin_hopping_runner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1boltzmann__sa.html">boltzmann_sa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boltzmann cooling schedule.  <a href="classcoptim_1_1boltzmann__sa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_cartesion_product.html">CartesionProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to compute the Cartesian product of the input vector of column_vectors.  <a href="classcoptim_1_1_cartesion_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1cauchy__sa.html">cauchy_sa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cauchy cooling schedule.  <a href="classcoptim_1_1cauchy__sa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1fast__sa.html">fast_sa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast cooling schedule.  <a href="classcoptim_1_1fast__sa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_metropolis.html">Metropolis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a probabilistic acceptance criterion for candidate solutions.  <a href="classcoptim_1_1_metropolis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_minimizer.html">Minimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local minimizer.  <a href="classcoptim_1_1_minimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the output of an optimization.  <a href="structcoptim_1_1_optim_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoptim_1_1_random_number_generator.html">RandomNumberGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random numbers.  <a href="classcoptim_1_1_random_number_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range struct.  <a href="structcoptim_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoptim_1_1_storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores coordinate values and the associated cost.  <a href="structcoptim_1_1_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae44355a87cd47f270b86239b3c40d375"><td class="memItemLeft" align="right" valign="top">typedef dlib::matrix&lt; double, 0, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a></td></tr>
<tr class="separator:ae44355a87cd47f270b86239b3c40d375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cebfe4b9d11c56f3d4e563c745ef61"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; double(const <br class="typebreak" />
<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#af0cebfe4b9d11c56f3d4e563c745ef61">obj_func</a></td></tr>
<tr class="separator:af0cebfe4b9d11c56f3d4e563c745ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73a34dfdf194ef0b766f884667911ef"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#aa73a34dfdf194ef0b766f884667911ef">take_step_func</a></td></tr>
<tr class="separator:aa73a34dfdf194ef0b766f884667911ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846faebfe55dcc8448e94ba9cfa31c4"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; bool(double, <br class="typebreak" />
double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#ac846faebfe55dcc8448e94ba9cfa31c4">accept_test_func</a></td></tr>
<tr class="separator:ac846faebfe55dcc8448e94ba9cfa31c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccdeea3e9e73ae375fd9f2f83539042"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; const <br class="typebreak" />
<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>(const <br class="typebreak" />
<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a5ccdeea3e9e73ae375fd9f2f83539042">jac_func</a></td></tr>
<tr class="separator:a5ccdeea3e9e73ae375fd9f2f83539042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e382e2737ac482e8033b6cd120194"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">vect_states</a></td></tr>
<tr class="separator:a3c5e382e2737ac482e8033b6cd120194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cef2443caee6e123e7532fb9c8d067"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak" />
<a class="el" href="classcoptim_1_1base__schedule.html">base_schedule</a> *(*)()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#ae5cef2443caee6e123e7532fb9c8d067">schedule_map_type</a></td></tr>
<tr class="separator:ae5cef2443caee6e123e7532fb9c8d067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911e0ae8e09a06b6b2c7a02ac6080e0"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, <br class="typebreak" />
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a9911e0ae8e09a06b6b2c7a02ac6080e0">message_map_type</a></td></tr>
<tr class="separator:a9911e0ae8e09a06b6b2c7a02ac6080e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a907d31d38119e1bd7f8978b6f54596ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a907d31d38119e1bd7f8978b6f54596ee">basinhopping</a> (<a class="el" href="structcoptim_1_1basin__params.html">basin_params</a> &amp;params)</td></tr>
<tr class="memdesc:a907d31d38119e1bd7f8978b6f54596ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the global minimum of a function using the basin-hopping algorithm.  <a href="#a907d31d38119e1bd7f8978b6f54596ee">More...</a><br /></td></tr>
<tr class="separator:a907d31d38119e1bd7f8978b6f54596ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfab4dcfb1d25121a050b09ec2868f79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">vect_states</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#acfab4dcfb1d25121a050b09ec2868f79">build_input</a> (int num_dofs, const <a class="el" href="structcoptim_1_1range.html">range</a> &amp;rng)</td></tr>
<tr class="memdesc:acfab4dcfb1d25121a050b09ec2868f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the input to pass to <a class="el" href="classcoptim_1_1_cartesion_product.html" title="Class used to compute the Cartesian product of the input vector of column_vectors. ">CartesionProduct</a>.  <a href="#acfab4dcfb1d25121a050b09ec2868f79">More...</a><br /></td></tr>
<tr class="separator:acfab4dcfb1d25121a050b09ec2868f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef8f46ab7f5fb4737ed02b1b2cf590b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a8ef8f46ab7f5fb4737ed02b1b2cf590b">brute</a> (<a class="el" href="namespacecoptim.html#af0cebfe4b9d11c56f3d4e563c745ef61">obj_func</a> func, int num_dofs, const <a class="el" href="structcoptim_1_1range.html">range</a> &amp;rng, bool disp)</td></tr>
<tr class="memdesc:a8ef8f46ab7f5fb4737ed02b1b2cf590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the global minimum of a function using brute force.  <a href="#a8ef8f46ab7f5fb4737ed02b1b2cf590b">More...</a><br /></td></tr>
<tr class="separator:a8ef8f46ab7f5fb4737ed02b1b2cf590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15f83eb7efe9e755cf95461a7d7a8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#aa15f83eb7efe9e755cf95461a7d7a8f1">brute</a> (<a class="el" href="namespacecoptim.html#af0cebfe4b9d11c56f3d4e563c745ef61">obj_func</a> func, <a class="el" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">vect_states</a> &amp;input, bool disp)</td></tr>
<tr class="memdesc:aa15f83eb7efe9e755cf95461a7d7a8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the global minimum of a function using brute force.  <a href="#aa15f83eb7efe9e755cf95461a7d7a8f1">More...</a><br /></td></tr>
<tr class="separator:aa15f83eb7efe9e755cf95461a7d7a8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900387097784c43c9776407e15643e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a900387097784c43c9776407e15643e5a">get_bounds</a> (const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;x, double bounds)</td></tr>
<tr class="memdesc:a900387097784c43c9776407e15643e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default upper and lower limits.  <a href="#a900387097784c43c9776407e15643e5a">More...</a><br /></td></tr>
<tr class="separator:a900387097784c43c9776407e15643e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4a244a117dff118f92106ad5838cc1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a1b4a244a117dff118f92106ad5838cc1">rosen_derivative</a> (const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;m)</td></tr>
<tr class="memdesc:a1b4a244a117dff118f92106ad5838cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of Rosenbrock function (2D)  <a href="#a1b4a244a117dff118f92106ad5838cc1">More...</a><br /></td></tr>
<tr class="separator:a1b4a244a117dff118f92106ad5838cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c21c597dfe3b09c6783438a0b3b55d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a> (const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;m)</td></tr>
<tr class="memdesc:a28c21c597dfe3b09c6783438a0b3b55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rosenbrock function (2D)  <a href="#a28c21c597dfe3b09c6783438a0b3b55d">More...</a><br /></td></tr>
<tr class="separator:a28c21c597dfe3b09c6783438a0b3b55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af937df6bbfeaa968c2c0058b1ed22a9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#af937df6bbfeaa968c2c0058b1ed22a9b">Print</a> (const dlib::matrix&lt; double, 0, 1 &gt; &amp;v)</td></tr>
<tr class="separator:af937df6bbfeaa968c2c0058b1ed22a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713bb7260b8776c7dfbd63bec9aa246f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a713bb7260b8776c7dfbd63bec9aa246f">linspace</a> (double start, double stop, int num)</td></tr>
<tr class="memdesc:a713bb7260b8776c7dfbd63bec9aa246f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return evenly spaced numbers over a specified interval.  <a href="#a713bb7260b8776c7dfbd63bec9aa246f">More...</a><br /></td></tr>
<tr class="separator:a713bb7260b8776c7dfbd63bec9aa246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe3a550bd9ff44dd0106709408fd104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a1fe3a550bd9ff44dd0106709408fd104">associate_schedules</a> (<a class="el" href="namespacecoptim.html#ae5cef2443caee6e123e7532fb9c8d067">schedule_map_type</a> &amp;schedule_map)</td></tr>
<tr class="separator:a1fe3a550bd9ff44dd0106709408fd104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6e26ec573b135296fe11df26bd55c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a5c6e26ec573b135296fe11df26bd55c4">associate_messages</a> (<a class="el" href="namespacecoptim.html#a9911e0ae8e09a06b6b2c7a02ac6080e0">message_map_type</a> &amp;message_map)</td></tr>
<tr class="separator:a5c6e26ec573b135296fe11df26bd55c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ccbb0a1ff0a17a3b231330b3bdb596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#ac7ccbb0a1ff0a17a3b231330b3bdb596">anneal</a> (<a class="el" href="structcoptim_1_1anneal__params.html">anneal_params</a> &amp;params)</td></tr>
<tr class="memdesc:ac7ccbb0a1ff0a17a3b231330b3bdb596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize a function using simulated annealing.  <a href="#ac7ccbb0a1ff0a17a3b231330b3bdb596">More...</a><br /></td></tr>
<tr class="separator:ac7ccbb0a1ff0a17a3b231330b3bdb596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db21c37cbf58c5384ace222957de3ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5db21c37cbf58c5384ace222957de3ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoptim_1_1base__schedule.html">base_schedule</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecoptim.html#a5db21c37cbf58c5384ace222957de3ea">createInstance</a> ()</td></tr>
<tr class="separator:a5db21c37cbf58c5384ace222957de3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac846faebfe55dcc8448e94ba9cfa31c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;bool(double, double)&gt; <a class="el" href="namespacecoptim.html#ac846faebfe55dcc8448e94ba9cfa31c4">coptim::accept_test_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae44355a87cd47f270b86239b3c40d375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef dlib::matrix&lt;double, 0, 1&gt; <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ccdeea3e9e73ae375fd9f2f83539042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>(const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>&amp;)&gt; <a class="el" href="namespacecoptim.html#a5ccdeea3e9e73ae375fd9f2f83539042">coptim::jac_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9911e0ae8e09a06b6b2c7a02ac6080e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, std::string&gt; <a class="el" href="namespacecoptim.html#a9911e0ae8e09a06b6b2c7a02ac6080e0">coptim::message_map_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0cebfe4b9d11c56f3d4e563c745ef61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;double(const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;)&gt; <a class="el" href="namespacecoptim.html#af0cebfe4b9d11c56f3d4e563c745ef61">coptim::obj_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5cef2443caee6e123e7532fb9c8d067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classcoptim_1_1base__schedule.html">base_schedule</a> *(*)()&gt; <a class="el" href="namespacecoptim.html#ae5cef2443caee6e123e7532fb9c8d067">coptim::schedule_map_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa73a34dfdf194ef0b766f884667911ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;)&gt; <a class="el" href="namespacecoptim.html#aa73a34dfdf194ef0b766f884667911ef">coptim::take_step_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c5e382e2737ac482e8033b6cd120194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a>&gt; <a class="el" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">coptim::vect_states</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac7ccbb0a1ff0a17a3b231330b3bdb596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a> coptim::anneal </td>
          <td>(</td>
          <td class="paramtype">anneal_params &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize a function using simulated annealing. </p>
<p>Uses simulated annealing, a random algorithm that uses no derivative information from the function being optimized. Other names for this family of approaches include: "Monte Carlo", "Metropolis", "Metropolis-Hastings", <code>etc</code>. They all involve (a) evaluating the objective function on a random set of points, (b) keeping those that pass their randomized evaluation criteria, (c) cooling (<code>i.e.</code>, tightening) the evaluation criteria, and (d) repeating until their termination criteria are met. In practice they have been used mainly in discrete rather than in continuous optimization.</p>
<p>Available annealing schedules are 'fast', 'cauchy', and 'boltzmann'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>obj_func. The objective function to be minimized. Must be in the form 'double f(column_vector x)'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>column vector. An initial guess at the optimizing argument of <code>func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schedule</td><td>std:: string, optional. The annealing schedule to use. Must be one of 'fast', 'cauchy' or 'boltzmann'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T0</td><td>double, optional. The initial "temperature". If -1.0, then estimate it as 1.5 times the largest cost-function deviation over random points in the box-shaped region specified by the <code>lower, upper</code> input parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tf</td><td>double, optional. Final goal temperature. Cease iterations if the temperature falls below <code>Tf</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxeval</td><td>int, optional. Cease iterations if the number of function evaluations exceeds <code>maxeval</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxaccept</td><td>int, optional. Cease iterations if the number of points accepted exceeds <code>maxaccept</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>int, optional. Cease iterations if the number of cooling iterations exceeds <code>maxiter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_rate</td><td>double, optional. Scale constant for tuning the probabilistic acceptance criteria. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boltzmann</td><td>double, optional. Boltzmann constant in the probabilistic acceptance criteria (increase for less stringent criteria at each temperature). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feps</td><td>double, optional. Cease iterations if the relative errors in the function value over the last four coolings is below <code>feps</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quench</td><td>double, optional. Parameter to alter the <code>fast</code> simulated annealing schedule. See <code>Notes</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>double, optional. Parameter to alter the <code>fast</code> simulated annealing schedule. See <code>Notes</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>double, optional. Parameter to alter the <code>fast</code> simulated annealing schedule. See <code>Notes</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>column_vector, optional. Lower bounds on the argument <code>x</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>column_vector, optional. upper bounds on the argument <code>x</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dwell</td><td>int, optional. The number of times to execute the inner loop at each value of the temperature. See <code>Notes</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disp</td><td>bool, optional. Print a descriptive convergence message if true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>double, optional. Initial step size when generating random candidate solutions about the current position in global space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjust_step_interval</td><td>int, optional. Interval to adjust the step size based on the current the acceptance ratio. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window_size</td><td>int, optional. The algorithm will stop when the points within a window size specified are no longer changing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_cost</td><td>double, optional. Optimization will stop if the cost goes below. Default is <code>DBL_MIN</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_func</td><td>std::function&lt;void(column_vector&amp;)&gt;, optional. User defined step taking algorithm. Must take a dlib::matrix&lt;double, 0, 1&gt; (i.e. a <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a>) by reference and modify it in place. When the function is bound to an object using std::bind, the object must be created using new/delete to ensure object does not go out of scope. If none is provided a default adaptive step size will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polish</td><td>std::string, optional. Method to polish the output of simulated annealing before returning the result. The possible methods are "bfgs", "l-bfgs", "cg", or "bobyqa". If no method is specified then the result of anneal is not polished.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b><a class="el" href="structcoptim_1_1_optim_result.html" title="Stores the output of an optimization. ">OptimResult</a></b> A struct that contains member corresponding the output parameters. </dd>
<dd>
<b>x</b> : column_vector. The best solution found. </dd>
<dd>
<b>cost</b> : double. Value of the objective function at the best solution. </dd>
<dd>
<b>message</b> : std::string. Message detailing how the algorithm terminated. </dd>
<dd>
<b>success</b> : bool. Indicates if the solution had converged when the algorithm terminated. </dd>
<dd>
<b>niter</b> : int. The number of iterations completed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Simulated annealing is a random algorithm which uses no derivative information from the function being optimized. In practice it has been more useful in discrete optimization than continuous optimization, as there are usually better algorithms for continuous optimization problems. </dd>
<dd>
Some experimentation by trying the different temperature schedules and altering their parameters is likely required to obtain good performance. </dd>
<dd>
We give a brief description of how the three temperature schedules generate new points and vary their temperature. Temperatures are only updated with iterations in the outer loop. The inner loop is over loop <code>for(int i = 0; i &lt; dwell; i++)</code>, and new points are generated for every iteration in the inner loop. Whether the proposed new points are accepted is probabilistic. </dd>
<dd>
In the 'fast' schedule the updates are: <div class="fragment"><div class="line">T = pow(-c * k, quench);</div>
<div class="line">T = T0 * exp(T);</div>
<div class="line">k++;</div>
</div><!-- fragment --> </dd>
<dd>
In the 'cauchy' schedule the updates are: <div class="fragment"><div class="line">T = T0 / (1.0 + k);</div>
<div class="line">k++;</div>
</div><!-- fragment --></dd>
<dd>
In the 'boltzmann' schedule the updates are: <div class="fragment"><div class="line">k++;</div>
<div class="line">T = T0 / log(k + 1.0);</div>
</div><!-- fragment --></dd>
<dd>
Example <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="c_optim_8h.html">coptim.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//define an objective function</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>(<a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a> &amp;m)</div>
<div class="line">{</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> x = m(0);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> y = m(1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// compute Rosenbrock&#39;s function and return the result</span></div>
<div class="line"><span class="keywordflow">return</span> 100.0*pow(y - x*x, 2) + pow(1 - x, 2);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//define an initial starting point.</span></div>
<div class="line"><a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a> x0(2);</div>
<div class="line">x0 = 9, 9;</div>
<div class="line"></div>
<div class="line"><span class="comment">//initialize parameters and change the initial step size to 0.1 and set disp = true.</span></div>
<div class="line">coptim::anneal_param params = <a class="code" href="structcoptim_1_1anneal__params.html">coptim::anneal_params</a>(<a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>, x0).<a class="code" href="structcoptim_1_1anneal__params.html#a6bcba8f417ea2837c367beea439e0926">step_size</a>(0.1).<a class="code" href="structcoptim_1_1anneal__params.html#a81b84b91af4c4edb5dd659ef5d1fde8a">disp</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="structcoptim_1_1_optim_result.html">coptim::OptimResult</a> res = <a class="code" href="namespacecoptim.html#ac7ccbb0a1ff0a17a3b231330b3bdb596">coptim::anneal</a>(params);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c6e26ec573b135296fe11df26bd55c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coptim::associate_messages </td>
          <td>(</td>
          <td class="paramtype">message_map_type &amp;&#160;</td>
          <td class="paramname"><em>message_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fe3a550bd9ff44dd0106709408fd104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coptim::associate_schedules </td>
          <td>(</td>
          <td class="paramtype">schedule_map_type &amp;&#160;</td>
          <td class="paramname"><em>schedule_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a907d31d38119e1bd7f8978b6f54596ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a> coptim::basinhopping </td>
          <td>(</td>
          <td class="paramtype">basin_params &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the global minimum of a function using the basin-hopping algorithm. </p>
<p>Parameters are formed in a struct to allow individual values to be changed using the named parameter idiom. See <code>Notes</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>obj_func. The objective function to be minimized. Must be in the form 'double f(column_vector x)'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>column vector. An initial guess at the optimizing argument of <code>func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>column_vector, optional. upper bounds on the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>column_vector, optional. lower bounds on the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">niter</td><td>int, optional. Cease iterations if the number of cooling iterations exceeds <code>niter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>double, optional. The "temperature" parameter for the accept or reject criterion. Higher <code>T</code> mean that larger jumps in function value will be accepted. For best results <code>T</code> should be comparable to the separation (in function value) between local minima. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>double, optional. initial step size for use in the random displacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disp</td><td>bool, optional. Print a descriptive messages during evaluation if true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_cost</td><td>double, optional. Optimization will stop if the cost goes below. Default is <code>DBL_MIN</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">niter_success</td><td>int, optional. Stop the run if the global minimum candidate remains the same for this number of iterations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>std::string, optional. Local optimization technique to use during each iteration. Options are 'bfgs', 'lbfgs', or 'cg'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>int, optional. The number of previous iterations to store when approximating the Hessian matrix. Only used for lbfgs method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_func</td><td>std::function&lt;void(column_vector&amp;)&gt;, optional. User defined step taking algorithm. Must take a dlib::matrix&lt;double, 0, 1&gt; (i.e. a <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a>) by reference and modify it in place. When the function is bound to an object using std::bind, the object must be created using new/delete to ensure object does not go out of scope. If none is provided a default adaptive step size will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b><a class="el" href="structcoptim_1_1_optim_result.html" title="Stores the output of an optimization. ">OptimResult</a></b> A struct that contains member corresponding the output parameters. </dd>
<dd>
<b>x</b> : column_vector. The best solution found. </dd>
<dd>
<b>cost</b> : double. Value of the objective function at the best solution. </dd>
<dd>
<b>message</b>: std::string. Message detailing how the algorithm terminated. </dd>
<dd>
<b>success</b>: bool. Indicates if the solution had converged when the algorithm terminated. </dd>
<dd>
<b>niter</b> : int. The number of iterations completed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Example <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="c_optim_8h.html">coptim.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//define an objective function</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>(<a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a> &amp;m)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = m(0);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = m(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute Rosenbrock&#39;s function and return the result</span></div>
<div class="line">    <span class="keywordflow">return</span> 100.0*pow(y - x*x, 2) + pow(1 - x, 2);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//define an initial starting point.</span></div>
<div class="line"><a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a> x0(2);</div>
<div class="line">x0 = 9, 9;</div>
<div class="line"></div>
<div class="line"><span class="comment">//initialize parameters and change the initial step size to 0.1 and set disp = true.</span></div>
<div class="line">coptim::bain_param params = <a class="code" href="structcoptim_1_1basin__params.html">coptim::basin_params</a>(<a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>, x0).<a class="code" href="structcoptim_1_1basin__params.html#a39a3bef742858a4e01f61566d1279462">step_size</a>(0.1).<a class="code" href="structcoptim_1_1basin__params.html#aa0206ab226de8a6f822cb5dccf05476a">disp</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="structcoptim_1_1_optim_result.html">coptim::OptimResult</a> res = <a class="code" href="namespacecoptim.html#a907d31d38119e1bd7f8978b6f54596ee">coptim::basinhopping</a>(params);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ef8f46ab7f5fb4737ed02b1b2cf590b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a> coptim::brute </td>
          <td>(</td>
          <td class="paramtype">obj_func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const range &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the global minimum of a function using brute force. </p>
<p>Use this version of brute if all the DOFs vary over the same range. If any DOF has a range that is different that the others use <a class="el" href="namespacecoptim.html#aa15f83eb7efe9e755cf95461a7d7a8f1" title="Finds the global minimum of a function using brute force. ">brute(obj_func func, vect_states &amp;input, bool disp)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>obj_func. The objective function to be minimized. Must be in the form 'double f(column_vector x)'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_dofs</td><td>int. The number of degree of freedoms the objective function has. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rng</td><td>range. A range struct that specifies the start, end, and step size for the DOF ranges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disp</td><td>bool. Print a descriptive messages during evaluation if true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b><a class="el" href="structcoptim_1_1_optim_result.html" title="Stores the output of an optimization. ">OptimResult</a></b> A struct that contains member corresponding the output parameters. </dd>
<dd>
<b>x</b> : column_vector. The best solution found. </dd>
<dd>
<b>cost</b> : double. Value of the objective function at the best solution. </dd>
<dd>
<b>message</b>: std::string. Message detailing how the algorithm terminated. </dd>
<dd>
<b>success</b>: bool. Indicates if the solution had converged when the algorithm terminated. </dd>
<dd>
<b>niter</b> : int. The number of iterations completed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Example <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="c_optim_8h.html">coptim.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//define an objective function</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>(<a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> &amp;m)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = m(0);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = m(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute Rosenbrock&#39;s function and return the result</span></div>
<div class="line">    <span class="keywordflow">return</span> 100.0*pow(y - x*x, 2) + pow(1 - x, 2);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//define the number of degree of freedoms.</span></div>
<div class="line"><span class="keywordtype">int</span> num_dofs = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">//initialize a range struct to specify the grid to generate for testing the possible cost values.</span></div>
<div class="line"><a class="code" href="structcoptim_1_1range.html">coptim::range</a> rng = <a class="code" href="structcoptim_1_1range.html">coptim::range</a>(0.0, 3.0, .1) <span class="comment">//go from 0.0 to 3.0 in steps of 0.1</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacecoptim.html">coptim</a>::OptimResult res = <a class="code" href="namespacecoptim.html">coptim</a>::<a class="code" href="namespacecoptim.html#a8ef8f46ab7f5fb4737ed02b1b2cf590b">brute</a>(<a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>, num_dofs, rng, false);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa15f83eb7efe9e755cf95461a7d7a8f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoptim_1_1_optim_result.html">OptimResult</a> coptim::brute </td>
          <td>(</td>
          <td class="paramtype">obj_func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vect_states &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the global minimum of a function using brute force. </p>
<p>Use this version of brute if any of the DOFs require a different range than the others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>obj_func. The objective function to be minimized. Must be in the form 'double f(column_vector x)'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>vect_states. A vector of column_vectors (see <code><a class="el" href="typedefs_8h.html">typedefs.h</a></code> for specific typedef declarations) where each column_vector holds the possible values to test for that DOF and the size is the number of DOFs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disp</td><td>bool. Print a descriptive messages during evaluation if true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b><a class="el" href="structcoptim_1_1_optim_result.html" title="Stores the output of an optimization. ">OptimResult</a></b> A struct that contains member corresponding the output parameters. </dd>
<dd>
<b>x</b> : column_vector. The best solution found. </dd>
<dd>
<b>cost</b> : double. Value of the objective function at the best solution. </dd>
<dd>
<b>message</b>: std::string. Message detailing how the algorithm terminated. </dd>
<dd>
<b>success</b>: bool. Indicates if the solution had converged when the algorithm terminated. </dd>
<dd>
<b>niter</b> : int. The number of iterations completed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Example <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="c_optim_8h.html">coptim.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//define an objective function</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="namespacecoptim.html#a28c21c597dfe3b09c6783438a0b3b55d">rosen</a>(<a class="code" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a> &amp;m)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = m(0);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = m(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute Rosenbrock&#39;s function and return the result</span></div>
<div class="line">    <span class="keywordflow">return</span> 100.0*pow(y - x*x, 2) + pow(1 - x, 2);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//define the number of degree of freedoms.</span></div>
<div class="line"><span class="keywordtype">int</span> num_dofs = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">//initialize a range struct to specify the grid to generate for testing the possible cost values.</span></div>
<div class="line"><a class="code" href="structcoptim_1_1range.html">coptim::range</a> rng = <a class="code" href="structcoptim_1_1range.html">coptim::range</a>(0.0, 3.0, .1) <span class="comment">//go from 0.0 to 3.0 in steps of 0.1</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Build the input. This builds an input where all the DOFs are tested at the same values, but this is not required.</span></div>
<div class="line"><a class="code" href="namespacecoptim.html">coptim</a>::<a class="code" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">vect_states</a> inputs = <a class="code" href="namespacecoptim.html">coptim</a>::<a class="code" href="namespacecoptim.html#acfab4dcfb1d25121a050b09ec2868f79">build_input</a>(num_dofs, rng)</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacecoptim.html">coptim</a>::OptimResult res = <a class="code" href="namespacecoptim.html">coptim</a>::<a class="code" href="namespacecoptim.html#a8ef8f46ab7f5fb4737ed02b1b2cf590b">brute</a>(rosen, input, false);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="acfab4dcfb1d25121a050b09ec2868f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecoptim.html#a3c5e382e2737ac482e8033b6cd120194">vect_states</a> coptim::build_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const range &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the input to pass to <a class="el" href="classcoptim_1_1_cartesion_product.html" title="Class used to compute the Cartesian product of the input vector of column_vectors. ">CartesionProduct</a>. </p>
<p>Assumes the each DOF varies over the same range with the same step size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_dofs</td><td>int. The number of degree of freedoms the objective function has </td></tr>
    <tr><td class="paramname">rng</td><td>range. A range struct that specifies the start, end, and step size for the DOF ranges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vector of column_vectors that are then passed to <a class="el" href="classcoptim_1_1_cartesion_product.html" title="Class used to compute the Cartesian product of the input vector of column_vectors. ">CartesionProduct</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5db21c37cbf58c5384ace222957de3ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoptim_1_1base__schedule.html">base_schedule</a>* coptim::createInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a900387097784c43c9776407e15643e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> coptim::get_bounds </td>
          <td>(</td>
          <td class="paramtype">const column_vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the default upper and lower limits. </p>
<p>Defaults to an upper limit to 100.0 and a lower limit of -100.0 for every degree of freedom in the supplied column_vector x0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>column_vector. The initial starting point supplied by user. </td></tr>
    <tr><td class="paramname">bounds</td><td>double. The value the upper/lower bounds will be set to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column_vector. The column vector that will bound the algorithm's candidate solutions. </dd></dl>

</div>
</div>
<a class="anchor" id="a713bb7260b8776c7dfbd63bec9aa246f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; coptim::linspace </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return evenly spaced numbers over a specified interval. </p>
<p>Returns <code>num</code> evenly spaced samples, calculated over the interval <code>[start, stop]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>double. The starting value of the sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop</td><td>double. The end value of the sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>int. Number of samples to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>samples</b> std::vector&lt;double&gt;. There are <code>num</code> equally spaced samples in the closed interval <code>[start, stop]</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af937df6bbfeaa968c2c0058b1ed22a9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void coptim::Print </td>
          <td>(</td>
          <td class="paramtype">const dlib::matrix&lt; double, 0, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28c21c597dfe3b09c6783438a0b3b55d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double coptim::rosen </td>
          <td>(</td>
          <td class="paramtype">const column_vector &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rosenbrock function (2D) </p>
<p>function used for benchmarking optmization algorithms. Minimium expected at rosen(0,0) = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a>. The current (x, y) position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>Cost</b> double. The cost associated with the given (x, y) position. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b4a244a117dff118f92106ad5838cc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">column_vector</a> coptim::rosen_derivative </td>
          <td>(</td>
          <td class="paramtype">const column_vector &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative of Rosenbrock function (2D) </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a>. The current (x, y) position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>Derivative</b> <a class="el" href="namespacecoptim.html#ae44355a87cd47f270b86239b3c40d375">coptim::column_vector</a>. The gradient of the Rosenbrock function at the given (x, y) point. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 24 2014 18:08:00 for cOptim by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
